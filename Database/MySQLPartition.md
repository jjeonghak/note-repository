# 파티션
파티션 기능은 테이블을 논리적으로 하나의 테이블이지만 물리적으로 분리해서 관리  
주로 대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적  

<br>

## 파티션을 사용하는 이유
테이블의 데이터가 많아진다고 무조건 파티션을 적용하는 것이 효율적이지만은 않음  
대표적으로 하나의 테이블이 너무 커서 인덱스 크기가 물리적인 메모리보다 큰 경우나 주기적인 삭제 작업이 필요한 경우 파티션 활용  

<br>

### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

<img width="350" alt="partitionindex" src="https://github.com/user-attachments/assets/d5e40722-7f84-4445-ac40-87aaebbbd4f0" />

테이블 데이터는 물리 메모리보다 큰 것이 일반적이지만 인덱스의 워킹셋 물리 메모리보다 크다면 쿼리 성능이 급격하게 저하  
파티션을 통해 사용하는 인덱스를 조각화해서 물리 메모리를 효율적으로 사용 가능  

<br>

### 데이터의 물리적인 저장소를 분리
데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 그만큼 백업이나 관리 작업이 어려움  
파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분  
하지만 MySQL에서는 테이블의 파티션 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가지는 형태는 지원하지 않음  

<br>

### 이력 데이터의 효율적인 관리

<img width="550" alt="partitionlog" src="https://github.com/user-attachments/assets/08558158-6328-48a1-99dc-7b28a294f877" />


로그라는 이력 데이터는 단기간에 대량으로 누적되고 동시에 일정 기간이 지나면 쓸모가 없어짐  
다른 데이터에 비해 라이프 사이클이 상당히 짧은 것이 특징  
파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션 추가 및 삭제 방식으로 간단하게 해결 가능  

<br>

## MySQL 파티션의 내부 처리

```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE (YEAR(reg_date)) (
  PARTITION p2009 VALUES LSEE THAN (2010),
  PARTITION p2010 VALUES LSEE THAN (2011),
  PARTITION p2011 VALUES LSEE THAN (2012),
  PARTITION p9999 VALUES LSEE THAN MAXVALUE
);
```

<br>

### 파티션 테이블의 레코드 INSERT

<img width="650" alt="partitioninsert" src="https://github.com/user-attachments/assets/99ce1ce4-2931-4331-976d-123988a81f61" />

삽입되는 칼럼값 중에서 파티션 키를 이용해 파티션 표현식을 평가하고, 그 결과를 이용해 저장될 파티션 결정  
삽입되는 레코드를 위한 파티션이 결정되면 나머지 과정은 일반 테이블과 동일하게 처리  

<br>

### 파티션 테이블의 UPDATE

<img width="700" alt="partitionupdate" src="https://github.com/user-attachments/assets/3fa4e4bd-3111-46fc-8cf5-a3c435fbfcbe" />

변경 대상 레코드가 어느 파티션에 저장되어 있는지 탐색 필요  
조건절에 파티션 키 칼럼에 대한 조건이 존재한다면 빠르게 탐색 가능  
만약 조건절에 존재하지 않는가면 어떤 칼럼의 값을 변경하느냐에 따라 큰 차이 발생  

- 파티션 키 이외의 칼럼만 변경되는 경우 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경  
- 파티션 키 칼럼이 변경되는 경우 기존 레코드를 삭제한 후 새롭게 레코드를 저장  

<br>

### 파티션 테이블의 검색
파티션 테이블을 검색할때 성능에 크게 영향을 미치는 조건은 아래와 같음
- 조건절에 조건으로 검색해야할 파티션을 선택할 수 있는가?
- 조건절에 조건이 인덱스를 효율적으로(인덱스 레인지 스캔) 사용할 수 있는가?

<br>

두번째 사항은 파티션이 아닌 일반 테이블의 검색 성능에도 똑같은 영향  
하지만 파티션 테이블은 첫번째 사항의 결과에 따라 두번째 사항의 작업 내용이 상이  
- 파티션 선택 가능 + 인덱스 효율적 사용 = 특정 파티션에 대해 레인지 스캔  
- 파티션 선택 불가 + 인덱스 효율적 사용 = 모든 파티션에 대해 레인지 스캔  
- 파티션 선택 가능 + 인덱스 효율적 사용 불가 = 특정 파티션에 대해 풀 테이블 스캔  
- 파티션 선택 불가 + 인덱스 효율적 사용 불가 = 모든 파티션에 대해 풀 테이블 스캔  

<br>

### 파티션 테이블의 인덱스 스캔과 정렬

<img width="550" alt="localpartition" src="https://github.com/user-attachments/assets/6224596d-bfc6-42b6-9f5e-90a81ea6a2f8" />

MySQL의 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당  
모든 인덱스는 파티션 단위로 생성되며, 파티션과 관계없이 테이블 전체 단위로 글로벌하게 하나의 통합된 인덱스는 지원하지 않음  



































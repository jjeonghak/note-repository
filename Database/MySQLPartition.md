# 파티션
파티션 기능은 테이블을 논리적으로 하나의 테이블이지만 물리적으로 분리해서 관리  
주로 대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적  

<br>

## 파티션을 사용하는 이유
테이블의 데이터가 많아진다고 무조건 파티션을 적용하는 것이 효율적이지만은 않음  
대표적으로 하나의 테이블이 너무 커서 인덱스 크기가 물리적인 메모리보다 큰 경우나 주기적인 삭제 작업이 필요한 경우 파티션 활용  

<br>

### 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

<img width="350" alt="partitionindex" src="https://github.com/user-attachments/assets/d5e40722-7f84-4445-ac40-87aaebbbd4f0" />

테이블 데이터는 물리 메모리보다 큰 것이 일반적이지만 인덱스의 워킹셋 물리 메모리보다 크다면 쿼리 성능이 급격하게 저하  
파티션을 통해 사용하는 인덱스를 조각화해서 물리 메모리를 효율적으로 사용 가능  

<br>

### 데이터의 물리적인 저장소를 분리
데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 그만큼 백업이나 관리 작업이 어려움  
파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분  
하지만 MySQL에서는 테이블의 파티션 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가지는 형태는 지원하지 않음  

<br>

### 이력 데이터의 효율적인 관리

<img width="550" alt="partitionlog" src="https://github.com/user-attachments/assets/08558158-6328-48a1-99dc-7b28a294f877" />


로그라는 이력 데이터는 단기간에 대량으로 누적되고 동시에 일정 기간이 지나면 쓸모가 없어짐  
다른 데이터에 비해 라이프 사이클이 상당히 짧은 것이 특징  
파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션 추가 및 삭제 방식으로 간단하게 해결 가능  

<br>

## MySQL 파티션의 내부 처리

```sql
CREATE TABLE tb_article (
  article_id INT NOT NULL,
  reg_date DATETIME NOT NULL,
  ...
  PRIMARY KEY(article_id, reg_date)
) PARTITION BY RANGE (YEAR(reg_date)) (
  PARTITION p2009 VALUES LSEE THAN (2010),
  PARTITION p2010 VALUES LSEE THAN (2011),
  PARTITION p2011 VALUES LSEE THAN (2012),
  PARTITION p9999 VALUES LSEE THAN MAXVALUE
);
```

<br>

### 파티션 테이블의 레코드 INSERT

<img width="650" alt="partitioninsert" src="https://github.com/user-attachments/assets/99ce1ce4-2931-4331-976d-123988a81f61" />

삽입되는 칼럼값 중에서 파티션 키를 이용해 파티션 표현식을 평가하고, 그 결과를 이용해 저장될 파티션 결정  
삽입되는 레코드를 위한 파티션이 결정되면 나머지 과정은 일반 테이블과 동일하게 처리  

<br>

### 파티션 테이블의 UPDATE

<img width="700" alt="partitionupdate" src="https://github.com/user-attachments/assets/3fa4e4bd-3111-46fc-8cf5-a3c435fbfcbe" />

변경 대상 레코드가 어느 파티션에 저장되어 있는지 탐색 필요  
조건절에 파티션 키 칼럼에 대한 조건이 존재한다면 빠르게 탐색 가능  
만약 조건절에 존재하지 않는가면 어떤 칼럼의 값을 변경하느냐에 따라 큰 차이 발생  

- 파티션 키 이외의 칼럼만 변경되는 경우 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경  
- 파티션 키 칼럼이 변경되는 경우 기존 레코드를 삭제한 후 새롭게 레코드를 저장  

<br>

### 파티션 테이블의 검색
파티션 테이블을 검색할때 성능에 크게 영향을 미치는 조건은 아래와 같음
- 조건절에 조건으로 검색해야할 파티션을 선택할 수 있는가?
- 조건절에 조건이 인덱스를 효율적으로(인덱스 레인지 스캔) 사용할 수 있는가?

<br>

두번째 사항은 파티션이 아닌 일반 테이블의 검색 성능에도 똑같은 영향  
하지만 파티션 테이블은 첫번째 사항의 결과에 따라 두번째 사항의 작업 내용이 상이  
- 파티션 선택 가능 + 인덱스 효율적 사용 = 특정 파티션에 대해 레인지 스캔  
- 파티션 선택 불가 + 인덱스 효율적 사용 = 모든 파티션에 대해 레인지 스캔  
- 파티션 선택 가능 + 인덱스 효율적 사용 불가 = 특정 파티션에 대해 풀 테이블 스캔  
- 파티션 선택 불가 + 인덱스 효율적 사용 불가 = 모든 파티션에 대해 풀 테이블 스캔  

<br>

### 파티션 테이블의 인덱스 스캔과 정렬

<img width="550" alt="localpartition" src="https://github.com/user-attachments/assets/6224596d-bfc6-42b6-9f5e-90a81ea6a2f8" />

MySQL의 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당  
모든 인덱스는 파티션 단위로 생성되며, 파티션과 관계없이 테이블 전체 단위로 글로벌하게 하나의 통합된 인덱스는 지원하지 않음  

<br>

```
mysql> EXPLAIN
         SELECT *
         FROM tb_article
         WHERE reg_userid BETWEEN 'brew' AND 'toto'
           AND reg_date BETWEEN '2009-01-01' AND '2010-12-31'
         ORDER BY reg_userid;
+----+------------+-------------+-------+--------------+--------------------------+
| id | table      | partitions  | type  | key          | Extra                    |
+----+------------+-------------+-------+--------------+--------------------------+
|  1 | tb_article | p2009,p2010 | range | ix_reguserid | Using where; Using index |
+----+------------+-------------+-------+--------------+--------------------------+
```

여러 파티션에 대해 인덱스 스캔을 수행할때 각 파티션으로부터 레코드를 우선순위 큐에 임시 저장(머지 & 소트)  
결론적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 조회할때 별로의 정렬작업은 수행하지 않음  

<br>

### 파티션 프루닝
옵티마이저에 의해 필요한 파티션만 선별하고, 불필요한 파티션은 배제하는 것  

```
mysql> EXPLAIN SELECT * FROM tb_article WHERE reg_date > '2010-01-01' and reg_date < '2010-02-01';
+----+------------+------------+-------+---------+---------+------+--------------------------+
| id | table      | partitions | type  | key     | key_len | rows | Extra                    |
+----+------------+------------+-------+---------+---------+------+--------------------------+
|  1 | tb_article | p2010      | index | PRIMARY |       9 |    1 | Using where; Using index |
+----+------------+------------+-------+---------+---------+------+--------------------------+
```

<br>

## 파티션의 제약 사항
테이블 정의에서 `PARTITION BY RANGE` 절은 레이지 파티션을 사용한다는 것을 의미  
- 스토어드 루틴이나 UDF, 사용자 변수 등을 파티션의 표현식에 사용 불가
- 파티션 표현식에 일반적으로 칼럼 그 자체 또는 내장 함수를 사용 가능하지만, 일부 함수들은 파티션 프루닝 지원하지 않을 가능성 존재
- 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함 필수
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 보유 가능, 개별적 변경 및 추가 불가
- 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 보유 가능
- 최대 8192개의 파티션(서브 파티션 포함) 보유 가능
- 파티션 생성후 `sql_mode` 시스템 변수 변경은 데이터 파티션의 일관성을 깨뜨릴 가능성 존재
- 파티션 테이블에서 외래키 사용 불가
- 파티션 테이블은 전문 검색 인덱스 생성이나 쿼리 사용 불가
- 공간 데이터를 저장하는 칼럼 타입은 파티션 테이블 사용 불가
- 임시 테이블은 파티션 기능 사용 불가

<br>

## 파티션 사용시 주의사항
파티션 테이블의 경우 프라이머리 키를 포함한 유니크 키에 대해서 제약 사항 존재  
파티션의 목적이 작업의 범위를 좁히는 것이지만, 유니크 인덱스는 중복 레코드에 대한 체크 작업으로 인해 범위가 좁혀지지 않음  
또한 파티션은 일반 테이블과 같이 별도의 파일로 관리, 서버의 조작 가능 파일 개수와 연관된 제약 존재  

<br>

### 파티션과 유니크 키(프라이머리 키 포함)
종류와 관계없이 테이블에 유니크 인덱스가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함  

```sql
## 유니크 키와 파티션 키가 전혀 연관이 없기 때문에 불가능
CREATE TABLE tb_partition (
  fd1 INT NOT NULL,
  fd2 INT NOT NULL,
  fd3 INT NOT NULL,
  UNIQUE KEY (fd1, fd2)
) PARTITION BY HASH (fd3)
  PARTITIONS 4;

## 각각의 유니크 키로 파티션 결정 불가능
CREATE TABLE tb_partition (
  fd1 INT NOT NULL,
  fd2 INT NOT NULL,
  fd3 INT NOT NULL,
  UNIQUE KEY (fd1),
  UNIQUE KEY (fd2)
) PARTITION BY HASH (fd1 + fd2)
  PARTITIONS 4;

## 각각의 프라이머리 키와 유니크 키로 파티션 결정 불가능
CREATE TABLE tb_partition (
  fd1 INT NOT NULL,
  fd2 INT NOT NULL,
  fd3 INT NOT NULL,
  PRIMARY KEY (fd1),
  UNIQUE KEY (fd2, fd3)
) PARTITION BY HASH (fd1 + fd2)
  PARTITIONS 4;
```

<br>
